#pragma config(Sensor, S1,     touchL,         sensorEV3_Touch)
#pragma config(Sensor, S2,     distance,       sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     light,          sensorEV3_Color, modeEV3Color_Reflected_Raw)
#pragma config(Sensor, S4,     touchR,         sensorEV3_Touch)
#pragma config(Motor,  motorA,          left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorD,          right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int BLOCK_LENGTH = 650;
int turnDistance = 190;
const float ULTSO_CENTER_DIS = 11;
int initial_x = 4;
int initial_y = 3;
int end_x = 1;
int end_y = 1;
int currentDirection = 2;
float ultrasonicStart = 0;
string stringDirections;
string publicToilet;
int directions[69];
int counter = 0;
int calibrationCount = 0;
int numcal = 0;

task turnLeft() {
	setMotorSpeed(left, 10);
	setMotorSpeed(right, 10);
	sleep(10);
	resetMotorEncoder(left);
	resetMotorEncoder(right);
	moveMotorTarget(left, -turnDistance, -30);
	moveMotorTarget(right, turnDistance, 30);
	sleep(500);
	if (currentDirection == 1) {
		currentDirection = 4;
		} else {
		currentDirection--;
	}
}

task turnRight() {
	setMotorSpeed(left, 10);
	setMotorSpeed(right, 10);
	sleep(10);
	resetMotorEncoder(left);
	resetMotorEncoder(right);
	moveMotorTarget(left, turnDistance, 30);
	moveMotorTarget(right, -turnDistance, -30);
	sleep(500);
	if (currentDirection == 4) {
		currentDirection = 1;
		} else {
		currentDirection++;
	}
}

task main() {
	playTone(200, 200);
	wait10Msec(200);


	// Initialize directions array with zeros
	for (int i = 0; i < 69; i++) {
		directions[i] = 0;
	}

	resetMotorEncoder(left);
	resetMotorEncoder(right);

	while ((initial_x != end_x) || (initial_y != end_y)) {
		// If it can go right, turn right
		if (getUSDistance(S2) > ULTSO_CENTER_DIS) {
			startTask(turnRight);
			wait1Msec(1000);

			resetMotorEncoder(left);
			resetMotorEncoder(right);
			ultrasonicStart = getUSDistance(S2);
			while ((getMotorEncoder(left) + getMotorEncoder(right)) < (BLOCK_LENGTH * 2)) {
				setMotorSpeed(left, 40);
				setMotorSpeed(right, 40);
			}

			publicToilet = currentDirection;
			stringDirections += publicToilet;
			directions[counter] = currentDirection;
			counter++;
			numcal = 0;

			if (currentDirection == 1) {
				initial_y++;
				} else if (currentDirection == 2) {
				initial_x++;
				} else if (currentDirection == 3) {
				initial_y--;
				} else if (currentDirection == 4) {
				initial_x--;
			}

			setMotorSpeed(left, 0);
			setMotorSpeed(right, 0);
			wait1Msec(10);
			calibrationCount++;

			} else {
			if (calibrationCount >= 0 && numcal <= 1) {
				numcal++;
				startTask(turnRight); //Calibrates until line 129
				wait1Msec(1000);
				setMotorSpeed(left, 5);
				setMotorSpeed(right, 5);
				while (!(getTouchValue(S1) == 1 && getTouchValue(S4) == 1)) {
					if (getTouchValue(S1) == 1) {
						setMotorSpeed(left, -2);
					}
					if (getTouchValue(S4) == 1) {
						setMotorSpeed(right, -2);
					}
					wait1Msec(10);
					setMotorSpeed(left, 15);
					setMotorSpeed(right, 15);
					wait1Msec(1000);
					if (getTouchValue(S1) == 0 && getTouchValue(S4) == 0){
						moveMotorTarget(left, -20, -10);
						moveMotorTarget(right, -60, -10);
					}
				}
				resetMotorEncoder(left);
				resetMotorEncoder(right);
				moveMotorTarget(left, -180, -10);
				moveMotorTarget(right, -180, -10);
				wait1Msec(2000);
				setMotorSpeed(left, 0);
				setMotorSpeed(right, 0);
				wait1Msec(100);
				startTask(turnLeft);
				wait1Msec(1000);
				calibrationCount = 0;
			}
			startTask(turnLeft);
			wait1Msec(1000);
		}

		if (initial_x == end_x && initial_y == end_y) {
			playSound(soundFastUpwardTones);

			int x = 0;
			while (x < 4) {
				if (getUSDistance(S2) < ULTSO_CENTER_DIS) {
					startTask(turnRight);
					wait1Msec(2000);
					setMotorSpeed(left, 5);
					setMotorSpeed(right, 5);
					while (!(getTouchValue(S1) == 1 && getTouchValue(S4) == 1)) {
						if (getTouchValue(S1) == 1) {
							setMotorSpeed(left, -2);
						}
						if (getTouchValue(S4) == 1) {
							setMotorSpeed(right, -2);
						}
						wait1Msec(10);
						setMotorSpeed(left, 5);
						setMotorSpeed(right, 5);
					}
					resetMotorEncoder(left);
					resetMotorEncoder(right);
					moveMotorTarget(left, -180, -10);
					moveMotorTarget(right, -180, -10);
					wait1Msec(2000);
					setMotorSpeed(left, 0);
					setMotorSpeed(right, 0);
					wait1Msec(2000);
					startTask(turnLeft);
					wait1Msec(2000);
					startTask(turnRight);
					wait1Msec(2000);
					startTask(turnRight);
					} else {
					startTask(turnRight);
				}
				x++;
			}

			// Cancel out opposite movements directly in the main task
			bool cancelled;
			do {
				cancelled = false;
				for (int i = 0; i < counter - 1; i++) {
					if ((directions[i] == 1 && directions[i + 1] == 3) ||
						(directions[i] == 2 && directions[i + 1] == 4) ||
					(directions[i] == 3 && directions[i + 1] == 1) ||
					(directions[i] == 4 && directions[i + 1] == 2)) {

						// Shift remaining elements forward
						for (int j = i + 2; j < counter; j++) {
							directions[j - 2] = directions[j];
						}

						// Update counter to reflect removed elements
						counter -= 2;
						cancelled = true;

						// Break to restart loop
						break;
					}
				}
			} while (cancelled);

			break;  // Exit the loop once done
		}
	}

	// Follow the shortest path back to the starting point
	turnDistance = 190;
	playTone(200, 200);
	wait10Msec(200);
	for (int i = counter - 1; i >= 0; i--) {
		if (directions[i] != 0 && directions[i] != 9) {
			if (directions[i] <= 2) {
				while (currentDirection != directions[i] + 2) {
					startTask(turnRight);
					wait1Msec(1000);
				}
				} else {
				while (currentDirection != directions[i] - 2) {
					startTask(turnRight);
					wait1Msec(1000);
				}
			}

			resetMotorEncoder(left);
			resetMotorEncoder(right);
			ultrasonicStart = getUSDistance(S2);
			while ((getMotorEncoder(left) + getMotorEncoder(right)) < (BLOCK_LENGTH * 2)) {
				setMotorSpeed(left, 40);
				setMotorSpeed(right, 40);
			}
			if (currentDirection == 1) {
				initial_y++;
				} else if (currentDirection == 2) {
				initial_x++;
				} else if (currentDirection == 3) {
				initial_y--;
				} else if (currentDirection == 4) {
				initial_x--;
			}

			if (initial_x == end_x && initial_y == end_y) {
				playSound(soundFastUpwardTones);
				break;
			}
		}
	}
}
